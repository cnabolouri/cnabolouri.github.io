<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tetris (Vanilla JS)</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --line:#374151; --text:#e5e7eb; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--text);
           min-height:100vh; display:grid; place-items:center;
           font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial; }
    .wrap { width:min(720px,96vw); }
    h1 { margin:0 0 12px; }
    .card { background:var(--panel); border:1px solid var(--line);
            border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.25); }
    .row { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px; flex-wrap:wrap; }
    .btn { border-radius:10px; padding:10px 14px; font-weight:700;
           border:1px solid var(--line); background:#0b1220; color:var(--text); cursor:pointer; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .btn:hover { background:#10182a; }
    .stats { display:flex; gap:14px; font-size:.95rem; opacity:.9; }
    .stage { display:grid; grid-template-columns: 1fr auto; gap:16px; }
    #canvas { display:block; border-radius:12px; border:1px solid var(--line); background:#0b1220; touch-action:none; }
    .side { min-width:160px; display:flex; flex-direction:column; gap:10px; }
    .panel { border:1px solid var(--line); border-radius:12px; padding:10px; }
    .label { font-size:.85rem; opacity:.8; margin-bottom:6px; }
    /* Mobile control bar */
    .controls-mobile { display:grid; grid-template-columns:repeat(5,1fr); gap:8px; margin-top:10px; }
    .controls-mobile .btn { padding:12px 8px; }
    @media (min-width: 800px) { .controls-mobile { display:none; } } /* hide on bigger screens */
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üß± Tetris (JS)</h1>
    <div class="card">
      <div class="row">
        <div>
          <strong id="status">Press ‚ñ∂ Start</strong>
          <div class="stats">
            <div>Score: <span id="score">0</span></div>
            <div>Lines: <span id="lines">0</span></div>
            <div>Level: <span id="level">1</span></div>
            <div>Best: <span id="best">0</span></div>
          </div>
        </div>
        <div style="display:flex; gap:8px;">
          <button id="start" class="btn">‚ñ∂ Start</button>
          <button id="pause" class="btn" disabled>‚è∏ Pause</button>
          <button id="reset" class="btn">‚Ü∫ Reset</button>
        </div>
      </div>

      <div class="stage">
        <canvas id="canvas" width="320" height="640" aria-label="Tetris board" role="img"></canvas>

        <div class="side">
          <div class="panel">
            <div class="label">Next</div>
            <canvas id="next" width="120" height="120"></canvas>
          </div>
          <div class="panel">
            <div class="label">Help</div>
            <div style="font-size:.9rem; opacity:.9; line-height:1.4;">
              ‚Üê/‚Üí move<br>‚Üë or X rotate CW<br>Z rotate CCW<br>‚Üì soft drop<br>Space hard drop<br>P pause, R reset
            </div>
          </div>
        </div>
      </div>

      <!-- Mobile controls -->
      <div class="controls-mobile">
        <button class="btn" id="m-left">‚óÄ</button>
        <button class="btn" id="m-ccw">‚ü≤</button>
        <button class="btn" id="m-drop">‚¨áÔ∏é Drop</button>
        <button class="btn" id="m-cw">‚ü≥</button>
        <button class="btn" id="m-right">‚ñ∂</button>
      </div>
    </div>
  </div>

  <script>
  const showError = (e) => { const s = document.getElementById('status'); if (s) s.textContent = 'Error: '+(e?.message||e); console.error(e); };

  try {
    // ====== CONFIG ======
    const COLS=10, ROWS=20, TILE=32;           // board: 10x20, each tile 32 CSS px
    const COLORS = [ "#000000", "#00c7ff", "#ffd600", "#b15cff", "#42e37b", "#ff6b6b", "#4c78ff", "#ff9f40" ];
    // index:     0        I         O          T          S          Z          J          L

    // ====== CANVAS SETUP (crisp) ======
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('next');
    const nctx = nextCanvas.getContext('2d');
    const DPR = window.devicePixelRatio || 1;

    function scaleCanvas(c, w, h) {
      c.style.width = w + 'px'; c.style.height = h + 'px';
      c.width = w * DPR; c.height = h * DPR;
      c.getContext('2d').scale(DPR, DPR);
    }
    scaleCanvas(canvas, COLS*TILE, ROWS*TILE);
    scaleCanvas(nextCanvas, 120, 120);

    // ====== UI ======
    const statusEl=document.getElementById('status');
    const scoreEl=document.getElementById('score');
    const linesEl=document.getElementById('lines');
    const levelEl=document.getElementById('level');
    const bestEl=document.getElementById('best');
    const startBtn=document.getElementById('start');
    const pauseBtn=document.getElementById('pause');
    const resetBtn=document.getElementById('reset');

    // Safe localStorage
    const BEST_KEY="tetris-best-v1";
    let storageOK=true; try { localStorage.setItem("__tetris_test","1"); localStorage.removeItem("__tetris_test"); } catch(_) { storageOK=false; }
    const getBest=()=> storageOK ? Number(localStorage.getItem(BEST_KEY)||0) : Number(bestEl.textContent||0);
    const setBest=(v)=>{ if(storageOK){ try{ localStorage.setItem(BEST_KEY,String(v)); }catch(_){} } bestEl.textContent=v; };
    setBest(getBest());

    // ====== BOARD & PIECES ======
    const emptyRow = () => new Array(COLS).fill(0);
    const createBoard = () => Array.from({length:ROWS}, emptyRow);

    const SHAPES = {
      I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      O: [[1,1],[1,1]],
      T: [[0,1,0],[1,1,1]],
      S: [[0,1,1],[1,1,0]],
      Z: [[1,1,0],[0,1,1]],
      J: [[1,0,0],[1,1,1]],
      L: [[0,0,1],[1,1,1]],
    };
    const ORDER = ['I','O','T','S','Z','J','L'];
    const IDMAP = {I:1,O:2,T:3,S:4,Z:5,J:6,L:7};

    function rotate(mat, dir = 1) {
      const rows = mat.length;
      const cols = mat[0].length;
      // result will be cols x rows
      const out = Array.from({ length: cols }, () => Array(rows).fill(0));

      if (dir > 0) {
        // CW: out[i][rows-1-j] = mat[j][i]
        for (let j = 0; j < rows; j++) {
          for (let i = 0; i < cols; i++) {
            out[i][rows - 1 - j] = mat[j][i];
          }
        }
      } else {
        // CCW: out[cols-1-i][j] = mat[j][i]
        for (let j = 0; j < rows; j++) {
          for (let i = 0; i < cols; i++) {
            out[cols - 1 - i][j] = mat[j][i];
          }
        }
      }
      return out;
    }

    function collides(board, piece){
      const {x,y,mat} = piece;
      for (let j=0;j<mat.length;j++){
        for (let i=0;i<mat[j].length;i++){
          if (!mat[j][i]) continue;
          const nx = x+i, ny = y+j;
          if (nx<0 || nx>=COLS || ny>=ROWS) return true;
          if (ny>=0 && board[ny][nx]) return true;
        }
      }
      return false;
    }

    function merge(board, piece){
      const {x,y,mat,id}=piece;
      for (let j=0;j<mat.length;j++){
        for (let i=0;i<mat[j].length;i++){
          if (mat[j][i] && y+j>=0) board[y+j][x+i] = id;
        }
      }
    }

    // bag randomizer
    let bag=[];
    function nextFromBag(){
      if (bag.length===0) bag = ORDER.slice().sort(()=>Math.random()-0.5);
      return bag.pop();
    }

    // ====== GAME STATE ======
    let board, piece, nextType, running=false, paused=false, gameOver=false;
    let score=0, lines=0, level=1;
    let lastTime=0, dropCounter=0, dropInterval=1000;

    function setStatus(t){ statusEl.textContent=t; }
    function updateUI(){
      scoreEl.textContent=score;
      linesEl.textContent=lines;
      levelEl.textContent=level;
      setBest(Math.max(getBest(), score));
    }
    function levelSpeed(){
      // faster each level; min 120ms
      return Math.max(120, 1000 - (level-1)*80);
    }

    function spawn(){
      const type = nextType ?? nextFromBag();
      nextType = nextFromBag();
      // center horizontally; y = -1 to allow spawn above board
      const matBase = SHAPES[type];
      piece = { x: Math.floor((COLS - matBase[0].length)/2), y: -1, mat: matBase.map(r=>r.slice()), id: IDMAP[type] };
      // draw next preview
      drawNext();
      // if already colliding -> game over
      if (collides(board, piece)){ endGame(); }
    }

    function drawNext(){
      nctx.clearRect(0,0,nextCanvas.width/DPR,nextCanvas.height/DPR);
      const mat = SHAPES[nextType].map(r=>r.slice());
      const id = IDMAP[nextType];
      const size = 24;
      // center in 120x120
      const w = mat[0].length*size, h = mat.length*size;
      const ox = Math.floor((120 - w)/2), oy = Math.floor((120 - h)/2);
      nctx.fillStyle = "#0b1220"; nctx.fillRect(0,0,120,120);
      for (let j=0;j<mat.length;j++){
        for (let i=0;i<mat[j].length;i++){
          if (!mat[j][i]) continue;
          drawCell(nctx, ox+i*size, oy+j*size, size, COLORS[id], true);
        }
      }
    }

    function reset(){
      board = createBoard();
      score=0; lines=0; level=1;
      dropInterval = levelSpeed();
      running=false; paused=false; gameOver=false;
      nextType = nextFromBag();
      spawn();
      updateUI();
      setStatus("Ready. Press ‚ñ∂ Start");
      pauseBtn.disabled = true; startBtn.disabled = false;
      draw();
    }

    // ====== INPUT ======
    function tryMove(dx, dy){
      const oldX=piece.x, oldY=piece.y;
      piece.x += dx; piece.y += dy;
      if (collides(board,piece)){ piece.x=oldX; piece.y=oldY; return false; }
      return true;
    }

    function tryRotate(dir){
      const old = piece.mat;
      const rotated = rotate(piece.mat, dir);
      const oldX = piece.x;
      piece.mat = rotated;
      // basic wall-kicks: 0, -1, +1, -2, +2
      const kicks = [0,-1,1,-2,2];
      for (const k of kicks){
        piece.x = oldX + k;
        if (!collides(board,piece)) return true;
      }
      piece.mat = old; piece.x = oldX; return false;
    }

    function softDrop(){ if (running && !paused) { if (!tryMove(0,1)) lockPiece(); else score += 1, updateUI(); } }
    function hardDrop(){
      if (!(running && !paused)) return;
      let dist=0;
      while (tryMove(0,1)) dist++;
      score += dist*2; updateUI();
      lockPiece();
    }

    window.addEventListener('keydown', (e)=>{
      const k=e.key.toLowerCase();
      const nav = ["arrowleft","arrowright","arrowdown","arrowup"].includes(k);
      if (nav || k===" " || k==="z" || k==="x" || k==="p" || k==="r") e.preventDefault();
      if (!running){ if (k===" "||k==="enter") start(); return; }
      if (gameOver) return;

      if (k==="p" || (k===" " && paused)) togglePause();
      else if (paused) return;

      if (k==="arrowleft") tryMove(-1,0);
      else if (k==="arrowright") tryMove(1,0);
      else if (k==="arrowdown") softDrop();
      else if (k==="arrowup" || k==="x") tryRotate(1);
      else if (k==="z") tryRotate(-1);
      else if (k===" ") hardDrop();
      else if (k==="r") reset();

      draw();
    });

    // Mobile buttons
    const btn = id => document.getElementById(id);
    btn('m-left').addEventListener('click', ()=>{ if (running && !paused){ tryMove(-1,0); draw(); }});
    btn('m-right').addEventListener('click', ()=>{ if (running && !paused){ tryMove(1,0); draw(); }});
    btn('m-ccw').addEventListener('click', ()=>{ if (running && !paused){ tryRotate(-1); draw(); }});
    btn('m-cw').addEventListener('click', ()=>{ if (running && !paused){ tryRotate(1); draw(); }});
    btn('m-drop').addEventListener('click', ()=> hardDrop());

    // Buttons
    startBtn.addEventListener('click', start);
    pauseBtn.addEventListener('click', togglePause);
    resetBtn.addEventListener('click', reset);

    function start(){
      if (running) return;
      running = true; paused=false; gameOver=false;
      setStatus("Go!");
      startBtn.disabled = true; pauseBtn.disabled = false;
      lastTime = 0; dropCounter = 0;
      requestAnimationFrame(update);
    }
    function togglePause(){
      if (!running || gameOver) return;
      paused = !paused;
      setStatus(paused ? "Paused ‚Äî press ‚ñ∂ Resume" : "Go!");
      pauseBtn.textContent = paused ? "‚ñ∂ Resume" : "‚è∏ Pause";
      if (!paused) { lastTime = 0; requestAnimationFrame(update); }
    }
    function endGame(){
      running=false; gameOver=true; pauseBtn.disabled = true; startBtn.disabled = true;
      setStatus("Game Over ‚Äî ‚Ü∫ Reset");
      draw();
    }

    // ====== TICK / LOCK / CLEAR ======
    function lockPiece(){
      merge(board, piece);
      const cleared = sweep();
      if (cleared>0){
        // Scoring: single 100, double 300, triple 500, tetris 800 (√ó level)
        const base=[0,100,300,500,800][cleared] || cleared*200;
        score += base * level;
        lines += cleared;
        const newLevel = Math.floor(lines/10)+1;
        if (newLevel !== level){
          level = newLevel;
          dropInterval = levelSpeed();
        }
        updateUI();
      }
      spawn();
      draw();
    }

    function sweep(){
      let row, count=0;
      for (let y=ROWS-1;y>=0;y--){
        if (board[y].every(v=>v!==0)){
          row = board.splice(y,1)[0];
          board.unshift(emptyRow());
          y++; count++;
        }
      }
      return count;
    }

    function update(time=0){
      if (!running || paused) return;
      if (!lastTime) lastTime = time;
      const delta = time - lastTime;
      lastTime = time;
      dropCounter += delta;
      if (dropCounter > dropInterval){
        dropCounter = 0;
        if (!tryMove(0,1)) lockPiece();
      }
      draw();
      if (running && !paused) requestAnimationFrame(update);
    }

    // ====== DRAW ======
    function drawCell(ctx,x,y,size,color,rounded=false,ghost=false){
      ctx.fillStyle = ghost ? color + "55" : color;
      if (rounded){
        const r = Math.min(8, size/3);
        ctx.beginPath();
        ctx.moveTo(x+r, y);
        ctx.arcTo(x+size,y, x+size,y+size, r);
        ctx.arcTo(x+size,y+size, x, y+size, r);
        ctx.arcTo(x, y+size, x, y, r);
        ctx.arcTo(x, y, x+size, y, r);
        ctx.fill();
      } else {
        ctx.fillRect(x,y,size,size);
      }
      // subtle inner shading
      if (!ghost){
        ctx.strokeStyle = "rgba(255,255,255,.08)";
        ctx.strokeRect(x+0.5,y+0.5,size-1,size-1);
      }
    }

    function drawBoard(){
      ctx.fillStyle="#0b1220"; ctx.fillRect(0,0,COLS*TILE,ROWS*TILE);
      // grid
      ctx.strokeStyle="rgba(255,255,255,.05)";
      for (let x=1;x<COLS;x++){ ctx.beginPath(); ctx.moveTo(x*TILE,0); ctx.lineTo(x*TILE,ROWS*TILE); ctx.stroke(); }
      for (let y=1;y<ROWS;y++){ ctx.beginPath(); ctx.moveTo(0,y*TILE); ctx.lineTo(COLS*TILE,y*TILE); ctx.stroke(); }
      // cells
      for (let y=0;y<ROWS;y++){
        for (let x=0;x<COLS;x++){
          const v=board[y][x]; if (!v) continue;
          drawCell(ctx, x*TILE, y*TILE, TILE, COLORS[v], true, false);
        }
      }
    }

    function drawPiece(p, ghost=false){
      const {x,y,mat,id} = p;
      for (let j=0;j<mat.length;j++){
        for (let i=0;i<mat[j].length;i++){
          if (!mat[j][i]) continue;
          const xx=(x+i)*TILE, yy=(y+j)*TILE;
          if (yy >= 0) drawCell(ctx, xx, yy, TILE, COLORS[id], true, ghost);
        }
      }
    }

    function ghostOf(p){
      const g = { x:p.x, y:p.y, mat:p.mat, id:p.id };
      while (!collides(board,{...g,y:g.y+1})) g.y++;
      return g;
    }

    function draw(){
      drawBoard();
      if (piece){
        const g = ghostOf(piece);
        drawPiece(g, true);
        drawPiece(piece, false);
      }
    }

    // boot
    reset();
  } catch(e){ showError(e); }
  </script>
</body>
</html>
